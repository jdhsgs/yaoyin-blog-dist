(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{646:function(n,t,s){"use strict";s.r(t);var e=s(12),i=Object(e.a)({},(function(){var n=this.$createElement,t=this._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("p",[this._v("#长度最小的子数组\n##找到数组中满足其和>=s的长度最小的连续子数组\n###解法\n1.暴力求解\n首先定义int型的最小值min，用来存储数组长度的最小值，并首先赋予它初值为int型的最大值\n第一个for循环，遍历数组，作为寻找子数组的起点\n第二个for循环，累加到大于指定值s，并将这个长度与min进行对比。\n最后返回的时候如果min没有改变则返回0，改变了则返回min")]),this._v(" "),t("p",[this._v("2.滑动窗口\n不断调节子序列的起始位置和终点位置，从而得到我们想要的结果\n起始位置移动的条件：当窗口内的值大于s 窗口就要向前移动\n结束位置的移动就是遍历数组；\n起始位置的移动是关键：\nwhile(sum > s){\nsublength = j - i + 1;//窗口的长度\nresult  = result < sublength ? result : sublength;\nsum -= nums[i++];//滑动窗口的精髓，不断变更i（起始位置）\n}")])])}),[],!1,null,null,null);t.default=i.exports}}]);