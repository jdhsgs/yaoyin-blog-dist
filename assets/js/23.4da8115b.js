(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{651:function(s,t,n){"use strict";n.r(t);var a=n(10),e=Object(a.a)({},(function(){var s=this,t=s.$createElement,n=s._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"长度最小的子数组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#长度最小的子数组"}},[s._v("#")]),s._v(" 长度最小的子数组")]),s._v(" "),n("h2",{attrs:{id:"找到数组中满足其和-s的长度最小的连续子数组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#找到数组中满足其和-s的长度最小的连续子数组"}},[s._v("#")]),s._v(" 找到数组中满足其和>=s的长度最小的连续子数组")]),s._v(" "),n("h3",{attrs:{id:"解法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解法"}},[s._v("#")]),s._v(" 解法")]),s._v(" "),n("p",[s._v("1.暴力求解\n首先定义int型的最小值min，用来存储数组长度的最小值，并首先赋予它初值为int型的最大值\n第一个for循环，遍历数组，作为寻找子数组的起点\n第二个for循环，累加到大于指定值s，并将这个长度与min进行对比。\n最后返回的时候如果min没有改变则返回0，改变了则返回min")]),s._v(" "),n("p",[s._v("2.滑动窗口\n不断调节子序列的起始位置和终点位置，从而得到我们想要的结果\n起始位置移动的条件：当窗口内的值大于s 窗口就要向前移动\n结束位置的移动就是遍历数组；\n起始位置的移动是关键：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("while(sum > s){\n    sublength = j - i + 1;//窗口的长度\n    result  = result < sublength ? result : sublength;\n    sum -= nums[i++];//滑动窗口的精髓，不断变更i（起始位置）\n   }\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])])])}),[],!1,null,null,null);t.default=e.exports}}]);